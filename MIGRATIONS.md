# Database Migrations Guide

This guide provides comprehensive information on managing database migrations in the mexa-core project using Alembic.

## Table of Contents

1. [Overview](#overview)
2. [Migration Workflow](#migration-workflow)
3. [Common Patterns](#common-patterns)
4. [Safety Checklist](#safety-checklist)
5. [Production Rollbacks](#production-rollbacks)
6. [Troubleshooting](#troubleshooting)

## Overview

We use Alembic for database migrations to safely manage schema changes across environments (local, staging, production). Alembic provides:

- **Version control** for database schemas
- **Safe rollbacks** through downgrade functions
- **Autogeneration** of migrations from model changes
- **Transaction support** for atomic operations

## Migration Workflow

### Local Development → Staging → Production

#### 1. Local Development

**Create a new migration:**

```bash
# For manual migration
alembic revision -m "add user role column"

# For autogenerated migration (from model changes)
alembic revision --autogenerate -m "add user role column"
```

**Review and edit the migration:**
- Check the generated `upgrade()` and `downgrade()` functions
- Add data migrations if needed
- Ensure downgrade properly reverts changes
- Add helpful comments for complex operations

**Test locally:**

```bash
# Apply migration
alembic upgrade head

# Verify database state
alembic current

# Test rollback
alembic downgrade -1

# Re-apply
alembic upgrade head
```

**Commit the migration:**

```bash
git add migrations/versions/xxx_description.py
git commit -m "Add migration: description"
git push
```

#### 2. Staging Deployment

Before deploying to staging:

```bash
# Check migration status
alembic current

# Review pending migrations
alembic history

# Apply migrations
alembic upgrade head

# Verify
alembic current
```

**Testing in staging:**
- Run full test suite
- Verify application functionality
- Test rollback procedure
- Check performance impact

#### 3. Production Deployment

**Pre-deployment checklist:**
- ✅ All migrations tested in staging
- ✅ Rollback plan documented
- ✅ Database backup created
- ✅ Downtime window scheduled (if needed)
- ✅ Team notified

**Deployment:**

```bash
# Create backup (CRITICAL!)
pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME > backup_$(date +%Y%m%d_%H%M%S).sql

# Check current version
alembic current

# Apply migrations
alembic upgrade head

# Verify
alembic current
alembic history --verbose

# Test application
curl https://api.example.com/health
```

**If issues occur:**

```bash
# Rollback last migration
alembic downgrade -1

# Or rollback to specific version
alembic downgrade abc123

# Restore from backup (last resort)
psql -h $DB_HOST -U $DB_USER -d $DB_NAME < backup_YYYYMMDD_HHMMSS.sql
```

## Common Patterns

### Adding a Column

```python
def upgrade():
    op.add_column('table_name',
        sa.Column('new_column', sa.String(100), nullable=True)
    )

def downgrade():
    op.drop_column('table_name', 'new_column')
```

**Best practices:**
- Make new columns nullable initially
- Add data migration to populate existing rows
- Add NOT NULL constraint in separate migration if needed

### Creating an Index

```python
def upgrade():
    op.create_index(
        'ix_table_column',
        'table_name',
        ['column_name'],
        unique=False
    )

def downgrade():
    op.drop_index('ix_table_column', table_name='table_name')
```

**PostgreSQL concurrent indexes (zero downtime):**

```python
def upgrade():
    # Must be outside transaction
    op.execute('COMMIT')
    op.create_index(
        'ix_table_column',
        'table_name',
        ['column_name'],
        postgresql_concurrently=True
    )

def downgrade():
    op.execute('COMMIT')
    op.drop_index(
        'ix_table_column',
        table_name='table_name',
        postgresql_concurrently=True
    )
```

### Renaming a Column

```python
def upgrade():
    op.alter_column(
        'table_name',
        'old_column_name',
        new_column_name='new_column_name'
    )

def downgrade():
    op.alter_column(
        'table_name',
        'new_column_name',
        new_column_name='old_column_name'
    )
```

### Adding a Foreign Key

```python
def upgrade():
    # Add column first
    op.add_column('table_name',
        sa.Column('foreign_id', sa.Integer(), nullable=True)
    )
    
    # Create foreign key constraint
    op.create_foreign_key(
        'fk_table_foreign',
        'table_name',
        'foreign_table',
        ['foreign_id'],
        ['id'],
        ondelete='CASCADE'
    )

def downgrade():
    op.drop_constraint('fk_table_foreign', 'table_name', type_='foreignkey')
    op.drop_column('table_name', 'foreign_id')
```

### Data Migration

```python
from alembic import op
import sqlalchemy as sa
from sqlalchemy import table, column

def upgrade():
    # Define table for data operations
    users_table = table('users',
        column('id', sa.Integer),
        column('status', sa.String),
        column('is_active', sa.Boolean)
    )
    
    # Add new column
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
    
    # Migrate data: set is_active based on status
    op.execute(
        users_table.update()
        .where(users_table.c.status == 'active')
        .values(is_active=True)
    )
    
    op.execute(
        users_table.update()
        .where(users_table.c.status != 'active')
        .values(is_active=False)
    )
    
    # Make column non-nullable after data is populated
    op.alter_column('users', 'is_active', nullable=False)

def downgrade():
    op.drop_column('users', 'is_active')
```

### Adding Check Constraints

```python
def upgrade():
    op.create_check_constraint(
        'ck_users_age_positive',
        'users',
        'age > 0'
    )

def downgrade():
    op.drop_constraint('ck_users_age_positive', 'users', type_='check')
```

## Safety Checklist

Before running migrations in production:

### Pre-Migration
- [ ] Migration tested in local environment
- [ ] Migration tested in staging environment
- [ ] Database backup created
- [ ] Downgrade function tested and verified
- [ ] Migration reviewed by team member
- [ ] Performance impact assessed
- [ ] Rollback plan documented
- [ ] Downtime requirements communicated

### During Migration
- [ ] Monitor database locks
- [ ] Watch for slow queries
- [ ] Check application logs
- [ ] Verify no errors in migration output

### Post-Migration
- [ ] Verify migration applied: `alembic current`
- [ ] Test critical application endpoints
- [ ] Check application logs for errors
- [ ] Monitor database performance
- [ ] Verify data integrity

## Production Rollbacks

### When to Rollback

Rollback if you encounter:
- Migration errors or failures
- Data corruption
- Severe performance degradation
- Application errors related to schema changes

### Rollback Procedures

#### Option 1: Alembic Downgrade (Preferred)

```bash
# Rollback last migration
alembic downgrade -1

# Rollback to specific version
alembic downgrade abc123

# Rollback all migrations
alembic downgrade base
```

#### Option 2: Database Restore (Last Resort)

```bash
# Stop application
systemctl stop mexa-core

# Restore from backup
psql -h $DB_HOST -U $DB_USER -d $DB_NAME < backup_YYYYMMDD_HHMMSS.sql

# Verify restoration
psql -h $DB_HOST -U $DB_USER -d $DB_NAME -c "SELECT * FROM alembic_version;"

# Restart application
systemctl start mexa-core
```

### Post-Rollback

After rolling back:
1. Document what went wrong
2. Fix the migration locally
3. Re-test thoroughly
4. Re-deploy with fixes

## Troubleshooting

### Migration Fails with "alembic_version table doesn't exist"

**Problem:** First time running migrations

**Solution:**
```bash
# Create alembic version table
alembic stamp head
```

### Migration Fails with "duplicate key" error

**Problem:** Unique constraint violation during data migration

**Solution:**
- Review and fix data conflicts manually
- Add data cleanup to migration script
- Use ON CONFLICT clauses in data migrations

### Can't downgrade: "downgrade() not implemented"

**Problem:** Migration missing downgrade function

**Solution:**
- Always implement downgrade() functions
- If truly irreversible, raise an exception with explanation:
```python
def downgrade():
    raise NotImplementedError(
        "This migration cannot be automatically reversed. "
        "Manual intervention required."
    )
```

### Migration creates too much downtime

**Problem:** Long-running migration locks tables

**Solutions:**
- Use concurrent index creation (PostgreSQL)
- Split large migrations into smaller steps
- Add columns as nullable first, populate data, then add constraints
- Consider blue-green deployment strategy

### Migrations out of sync between environments

**Problem:** Different migration states in staging vs production

**Solution:**
```bash
# Check current version
alembic current

# Check migration history
alembic history

# Stamp to specific version if needed (use with caution)
alembic stamp <revision>
```

### Autogenerate detects unwanted changes

**Problem:** `alembic revision --autogenerate` creates migrations for unchanged tables

**Solutions:**
- Ensure all models are imported in `env.py`
- Check that `target_metadata` is correctly set
- Review and edit autogenerated migrations before committing
- Use `include_schemas` config to limit which schemas are tracked

## Best Practices

1. **Always test migrations locally first**
2. **Include both upgrade and downgrade functions**
3. **Use transactions for data integrity**
4. **Add comments for complex operations**
5. **Keep migrations small and focused**
6. **Review autogenerated migrations carefully**
7. **Create database backups before production migrations**
8. **Document breaking changes clearly**
9. **Test rollback procedures**
10. **Monitor performance impact**

## Getting Help

- Review Alembic documentation: https://alembic.sqlalchemy.org/
- Check SQLAlchemy types: https://docs.sqlalchemy.org/en/latest/core/types.html
- Ask team for migration review
- Test in staging before production

---

**Remember:** Migrations are permanent changes to your database schema. Always proceed with caution and have a rollback plan ready.
